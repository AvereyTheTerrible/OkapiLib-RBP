Some C++11 features required by Fake\+It are not supported by M\+S\+VS C++ 2013. To overcome this, Fake\+It also contains standard C++ alternatives that compile on both M\+S\+VS C++ 2013 and G\+CC 4.\+8. All of the code samples in this Quickstart can be compiled by both M\+S\+VS C++ 2013 and G\+CC 4.\+8.


\begin{DoxyItemize}
\item \href{\#stubbing}{\texttt{ Stubbing}}
\item \href{\#invocation-matching}{\texttt{ Invocation Matching}}
\item \href{\#verification}{\texttt{ Verification}}
\item \href{\#spying}{\texttt{ Spying}}
\item \href{\#reset-mock-to-initial-state}{\texttt{ Reset Mock to Initial State}}
\item \href{\#inheritance--dynamic-casting}{\texttt{ Inheritance \& Dynamic Casting}}
\end{DoxyItemize}

Assuming we have the following interface\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{struct SomeInterface \{}
\DoxyCodeLine{   virtual int foo(int) = 0;}
\DoxyCodeLine{   virtual int bar(int,int) = 0;}
\DoxyCodeLine{\};}
\end{DoxyCode}
 \#\# Stubbing 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{// Stub a method to return a value once}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).Return(1);}
\DoxyCodeLine{}
\DoxyCodeLine{// Stub multiple return values (The next two lines do exactly the same)}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).Return(1,2,3);}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).Return(1).Return(2).Return(3);}
\DoxyCodeLine{}
\DoxyCodeLine{// Return the same value many times (56 in this example)}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).Return(Times<56>::of(1));}
\DoxyCodeLine{}
\DoxyCodeLine{// Return many values many times (First 100 calls will return 1, next 200 calls will return 2)}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).Return(Times<100>::of(1), Times<200>::of(2));}
\DoxyCodeLine{}
\DoxyCodeLine{// Always return a value (The next two lines do exactly the same)}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).AlwaysReturn(1);}
\DoxyCodeLine{mock[\&SomeInterface::foo] = 1;}
\end{DoxyCode}
 {\bfseries{What if I want to be more specific?}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{// Stub foo(1) to return the value '100' once (The next two lines do the same)}
\DoxyCodeLine{When(mock[\&SomeInterface::foo].Using(1)).Return(100);}
\DoxyCodeLine{When(mock[\&SomeInterface::foo](1)).Return(100);}
\DoxyCodeLine{}
\DoxyCodeLine{// Stub 'foo(1)' to always return '100'. For all other calls always return 0.}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).AlwaysReturn(0); // Any invocation of foo will return 0}
\DoxyCodeLine{When(mock[\&SomeInterface::foo].Using(1)).AlwaysReturn(100); // override only for 'foo(1)'}
\DoxyCodeLine{}
\DoxyCodeLine{// The next two lines do exactly the same}
\DoxyCodeLine{When(mock[\&SomeInterface::foo].Using(1)).AlwaysReturn(0);}
\DoxyCodeLine{mock[\&SomeInterface::foo].Using(1) = 0;}
\end{DoxyCode}
 {\bfseries{Can I stub a method to throw an exception?}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{// Throw once}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).Throw(exception());}
\DoxyCodeLine{// Throw several times}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).Throw(exception(),exception());}
\DoxyCodeLine{// Throw many times}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).Throw(Times<23>::of(exception()));}
\DoxyCodeLine{// Always throw}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).AlwaysThrow(exception());}
\end{DoxyCode}
 {\bfseries{Nice, but sometimes I need something more freestyle}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{// Do whatever you want using lambda expressions}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).Do([](int a)->int\{ ... \});}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).AlwaysDo([](int a)->int\{ ... \});}
\end{DoxyCode}
 \#\# Invocation Matching 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{// Stub foo to return 1 only when argument 'a' is even.}
\DoxyCodeLine{auto agrument\_a\_is\_even = [](int a)\{return a\%2==0;\};}
\DoxyCodeLine{When(mock[\&SomeInterface::foo].Matching(agrument\_a\_is\_even)).Return(1);}
\DoxyCodeLine{}
\DoxyCodeLine{// Throw exception only when argument 'a' is negative.}
\DoxyCodeLine{auto agrument\_a\_is\_negative = [](int a)\{return a < 0;\};}
\DoxyCodeLine{When(mock[\&SomeInterface::foo].Matching(agrument\_a\_is\_negative)).Throw(exception());}
\DoxyCodeLine{}
\DoxyCodeLine{// Stub bar to throw exception only when argument 'a' is bigger than argument 'b'.}
\DoxyCodeLine{auto a\_is\_bigger\_than\_b = [](int a, int b)\{return a > b;\};}
\DoxyCodeLine{When(mock[\&SomeInterface::bar].Matching(a\_is\_bigger\_than\_b)).Throw(exception());}
\end{DoxyCode}


\#\# Verification 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{Mock<SomeInterface> mock;}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).AlwaysReturn(1);}
\DoxyCodeLine{}
\DoxyCodeLine{SomeInterface \& i = mock.get();}
\DoxyCodeLine{}
\DoxyCodeLine{// Production code:}
\DoxyCodeLine{i.foo(1);}
\DoxyCodeLine{i.foo(2);}
\DoxyCodeLine{i.foo(3);}
\DoxyCodeLine{}
\DoxyCodeLine{// Verify foo was invoked at least once. (The four lines do exactly the same)}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo]);}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo]).AtLeastOnce();}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo]).AtLeast(1);}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo]).AtLeast(Times<1>());}
\DoxyCodeLine{}
\DoxyCodeLine{// Verify foo was invoked at exactly 3 times. (The next two lines do exactly the same)}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo]).Exactly(3);}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo]).Exactly(Times<3>());}
\DoxyCodeLine{}
\DoxyCodeLine{// Verify foo(1) was invoked exactly once}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo].Using(1)).Once();}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo].Using(1)).Exactly(Once);}
\end{DoxyCode}
 {\bfseries{Wow, can I verify the order of invocations too?}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{// Verify foo(1) was invoked before foo(3)}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo].Using(1), mock[\&SomeInterface::foo].Using(3));}
\end{DoxyCode}
 {\bfseries{What about an exact sequence? Can I verify an exact sequence of invocations?}}

Sure, you represent a sequence in the following way\+:

Two consecutive invocations of foo\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{mock[\&SomeInterface::foo] * 2}
\end{DoxyCode}
 An invocation of foo followed by an invocation of bar\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{mock[\&SomeInterface::foo] + mock[\&SomeInterface::bar]}
\end{DoxyCode}
 Two consecutive invocations of foo + bar, i.\+e. foo + bar + foo + bar 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{(mock[\&SomeInterface::foo] + mock[\&SomeInterface::bar]) * 2}
\end{DoxyCode}
 This way you can represent any sequence of invocations.

To verify that a specific sequence exists in the actual invocation sequence simply write\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{// verify the actual invocation sequence contains two consecutive invocations of foo at least once.}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo] * 2); }
\DoxyCodeLine{}
\DoxyCodeLine{// verify the actual invocation sequence contains two consecutive invocations of foo exactly once.}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo] * 2).Exactly(Once);}
\DoxyCodeLine{}
\DoxyCodeLine{// verify the actual invocation sequence contains an invocation of foo(1) followed by bar(1,2) exactly twice.}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo].Using(1) + mock[\&SomeInterface::bar].Using(1,2)).Exactly(Times<2>());}
\end{DoxyCode}
 {\bfseries{Can a sequence involve more than one mock instance?}}

Sure, a sequence can involve multiple mock instances. 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{Mock<SomeInterface> mock1;}
\DoxyCodeLine{Mock<SomeInterface> mock2;}
\DoxyCodeLine{}
\DoxyCodeLine{When(mock1[\&SomeInterface::foo]).AlwaysReturn(0);}
\DoxyCodeLine{When(mock2[\&SomeInterface::foo]).AlwaysReturn(0);}
\DoxyCodeLine{}
\DoxyCodeLine{SomeInterface \& i1 = mock1.get();}
\DoxyCodeLine{SomeInterface \& i2 = mock2.get();}
\DoxyCodeLine{}
\DoxyCodeLine{// Production code:}
\DoxyCodeLine{i1.foo(1);}
\DoxyCodeLine{i2.foo(1);}
\DoxyCodeLine{i1.foo(2);}
\DoxyCodeLine{i2.foo(2);}
\DoxyCodeLine{i1.foo(3);}
\DoxyCodeLine{i2.foo(3);}
\DoxyCodeLine{}
\DoxyCodeLine{// Verify exactly 3 occurrences of the sequence \{mock1.foo(any int) + mock2.foo(any int)\}.}
\DoxyCodeLine{Verify(mock1[\&SomeInterface::foo] + mock2[\&SomeInterface::foo]).Exactly(Times<3>());}
\end{DoxyCode}


\#\#\# Verify No Other Invocations 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{Mock<SomeInterface> mock;}
\DoxyCodeLine{When(mock[\&SomeInterface::foo]).AlwaysReturn(0);}
\DoxyCodeLine{When(mock[\&SomeInterface::bar]).AlwaysReturn(0);}
\DoxyCodeLine{SomeInterface\& i  = mock.get();}
\DoxyCodeLine{}
\DoxyCodeLine{// call foo twice and bar once.}
\DoxyCodeLine{i.foo(1);}
\DoxyCodeLine{i.foo(2);}
\DoxyCodeLine{i.bar("some string");}
\DoxyCodeLine{}
\DoxyCodeLine{// verify foo(1) was called.}
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo].Using(1));}
\DoxyCodeLine{}
\DoxyCodeLine{// Verify no other invocations of any method of mock. }
\DoxyCodeLine{// Will fail since foo(2) \& bar("some string") are not verified yet.}
\DoxyCodeLine{VerifyNoOtherInvocations(mock);}
\DoxyCodeLine{}
\DoxyCodeLine{// Verify no other invocations of method foo only.}
\DoxyCodeLine{// Will fail since foo(2) is not verified yet.}
\DoxyCodeLine{VerifyNoOtherInvocations(mock[\&SomeInterface::foo]);}
\DoxyCodeLine{ }
\DoxyCodeLine{Verify(mock[\&SomeInterface::foo].Using(2));}
\DoxyCodeLine{}
\DoxyCodeLine{// Verify no other invocations of any method of mock. }
\DoxyCodeLine{// Will fail since bar("some string") is not verified yet.}
\DoxyCodeLine{VerifyNoOtherInvocations(mock);}
\DoxyCodeLine{}
\DoxyCodeLine{// Verify no other invocations of method foo only.}
\DoxyCodeLine{// Will pass since both foo(1) \& foo(2) are now verified.}
\DoxyCodeLine{VerifyNoOtherInvocations(mock[\&SomeInterface::foo]);}
\DoxyCodeLine{}
\DoxyCodeLine{Verify(mock[\&SomeInterface::bar]); // verify bar was invoked (with any arguments)}
\DoxyCodeLine{}
\DoxyCodeLine{// Verify no other invocations of any method of mock. }
\DoxyCodeLine{// Will pass since foo(1) \& foo(2) \& bar("some string") are now verified.}
\DoxyCodeLine{VerifyNoOtherInvocations(mock);.}
\end{DoxyCode}
 \subsection*{Reset \mbox{\hyperlink{classMock}{Mock}} to Initial State}

In most cases you will need to reset the mock objects to the initial state before/after each test method. To do that simply add the following line for each mock object to the setup/teardown code of your tests. 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{mock.Reset();}
\end{DoxyCode}
 \subsection*{Spying}

In some cases it is very useful to spy an existing object. Fake\+It is the O\+N\+LY C++ open source mocking framework that supports spying. 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{class SomeClass \{}
\DoxyCodeLine{public:}
\DoxyCodeLine{   virtual int func1(int arg) \{}
\DoxyCodeLine{      return arg;}
\DoxyCodeLine{   \}}
\DoxyCodeLine{   virtual int func2(int arg) \{}
\DoxyCodeLine{      return arg;}
\DoxyCodeLine{   \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{SomeClass obj;}
\DoxyCodeLine{Mock<SomeClass> spy(obj);}
\DoxyCodeLine{}
\DoxyCodeLine{When(spy[\&SomeClass::func1]).AlwaysReturn(10); // Override to return 10}
\DoxyCodeLine{}
\DoxyCodeLine{SomeClass\& i = spy.get();}
\DoxyCodeLine{cout << i.func1(1); // will print 10. }
\DoxyCodeLine{cout << i.func2(1); // func2 is not stubbed.}
\end{DoxyCode}
 In general, all stubbing \& verifying features work on spy objects the same way they work on mock objects. \subsection*{Inheritance \& Dynamic Casting}


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{struct A \{}
\DoxyCodeLine{  virtual int foo() = 0;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{struct B : public A \{}
\DoxyCodeLine{  virtual int foo() override = 0;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{struct C : public B}
\DoxyCodeLine{\{}
\DoxyCodeLine{   virtual int foo() override = 0;}
\DoxyCodeLine{\};}
\end{DoxyCode}
 {\bfseries{upcast support}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{Mock<C> cMock;      }
\DoxyCodeLine{When(cMock[\&C::foo]).AlwaysReturn(0);}
\DoxyCodeLine{}
\DoxyCodeLine{C\& c = cMock.get();}
\DoxyCodeLine{B\& b = c;}
\DoxyCodeLine{A\& a = b;}
\DoxyCodeLine{}
\DoxyCodeLine{cout << c.foo(); // prints 0}
\DoxyCodeLine{cout << b.foo(); // prints 0}
\DoxyCodeLine{cout << a.foo(); // prints 0}
\end{DoxyCode}
 {\bfseries{dynamic\+\_\+cast support}} 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{C++\}}
\DoxyCodeLine{Mock<C,B,A> cMock;}
\DoxyCodeLine{When(cMock[\&C::foo]).AlwaysReturn(0);}
\DoxyCodeLine{}
\DoxyCodeLine{A\& a = cMock.get(); // get instance and upcast to A\&}
\DoxyCodeLine{}
\DoxyCodeLine{B\& b = dynamic\_cast<B\&>(a); // downcast to B\&}
\DoxyCodeLine{cout << b.foo(); // prints 0}
\DoxyCodeLine{}
\DoxyCodeLine{C\& c = dynamic\_cast<C\&>(a); // downcast to C\&}
\DoxyCodeLine{cout << c.foo(); // prints 0}
\end{DoxyCode}
 