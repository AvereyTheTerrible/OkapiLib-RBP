<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="md_docs_tutorials_walkthrough_basicAutonomousMovment" kind="page">
    <compoundname>md_docs_tutorials_walkthrough_basicAutonomousMovment</compoundname>
    <title>Moving Autonomously</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Arguably the most fundamental task with regard to creating a good autonomous routine is ensuring consistent and accurate movement of the chassis. Robotic autonomous movement is an unsolved problem even among professional engineers, so it is obviously a difficult task. OkapiLib makes it easy to get reasonably accurate autonomous movements.</para>
<para>The basis for this autonomous movement is the ChassisController class. Take a look at its <computeroutput>API &lt;../../api/chassis/controller/chassis-controller-integrated.html&gt;</computeroutput>_ for more detailed info on it.</para>
<para>We&apos;ll use a <computeroutput>ChassisControllerIntegrated</computeroutput> for this tutorial, using the V5 motors&apos; onboard PID makes setup a much quicker and easier process (No PID tuning needed!).</para>
<para>Let&apos;s start by creating the <computeroutput>ChassisControllerIntegrated</computeroutput> with drive motors in ports 1 and 2:</para>
<para>.. highlight: cpp .. code-block:: cpp :linenos:</para>
<para>using namespace okapi;</para>
<para>const int DRIVE_MOTOR_LEFT = 1; const int DRIVE_MOTOR_RIGHT = 2;</para>
<para>auto chassis = ChassisControllerBuilder() .withMotors(DRIVE_MOTOR_LEFT, -DRIVE_MOTOR_RIGHT) .build();</para>
<para>Now that we&apos;ve created a ChassisController, let&apos;s start moving around. There are two fundamental movement types - <computeroutput>moveDistance()</computeroutput> and <computeroutput>turnAngle()</computeroutput>, for moving forward/backward and turning on a point.</para>
<para>.. highlight: cpp .. code-block:: cpp :linenos:</para>
<para>using namespace okapi;</para>
<para>const int DRIVE_MOTOR_LEFT = 1; const int DRIVE_MOTOR_RIGHT = 2;</para>
<para>auto chassis = ChassisControllerBuilder() .withMotors(DRIVE_MOTOR_LEFT, -DRIVE_MOTOR_RIGHT) .build();</para>
<para>void autonomous() { // Move to first goal chassis-&gt;moveDistance(1000); // Turn to face second goal chassis-&gt;turnAngle(100); // Drive toward second goal chassis-&gt;moveDistance(1500); }</para>
<para>If you&apos;d like to set movements in real life units, that&apos;s possible as well. Just pass in the drive&apos;s gearset and dimensions, and then use the appropriate suffix for the units that you would like the movement to occur in.</para>
<para>.. highlight: cpp .. code-block:: cpp :linenos:</para>
<para>using namespace okapi;</para>
<para>const int DRIVE_MOTOR_LEFT = 1; const int DRIVE_MOTOR_RIGHT = 2; const auto WHEEL_DIAMETER = 4_in; const auto CHASSIS_WIDTH = 13.5_in;</para>
<para>auto chassis = ChassisControllerBuilder() .withMotors(DRIVE_MOTOR_LEFT, -DRIVE_MOTOR_RIGHT) .withGearset(AbstractMotor::gearset::green) .withDimensions({{WHEEL_DIAMETER, CHASSIS_WIDTH}, imev5GreenTPR}) .build();</para>
<para>void autonomous() { // Move 1 meter to the first goal chassis-&gt;moveDistance(1_m); // Turn 90 degrees to face second goal chassis-&gt;turnAngle(90_deg); // Drive 1 and a half feet toward second goal chassis-&gt;moveDistance(1.5_ft); } </para>
    </detaileddescription>
  </compounddef>
</doxygen>
