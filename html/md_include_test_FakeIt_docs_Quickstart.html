<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OkapiLib: Quickstart</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-doxygen.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OkapiLib
   &#160;<span id="projectnumber">4.0.0-beta8-odom</span>
   </div>
   <div id="projectbrief">A PROS library for programming VEX robots.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Quickstart </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="#stubbing">Stubbing</a></li>
<li><a href="#invocation-matching">Invocation Matching</a></li>
<li><a href="#verification">Verification</a></li>
<li><a href="#spying">Spying</a></li>
<li><a href="#reset-mock-to-initial-state">Reset Mock to Initial State</a></li>
<li><a href="#inheritance--dynamic-casting">Inheritance &amp; Dynamic Casting</a></li>
</ul>
<p>FakeIt is designed for simplicity and expressiveness. This design goal is achieved by using many of C++11 language features, including Variadic templates, Lambda expressions &amp; User-defined literals and more. Some of these C++11 features (like User-defined literals) are not fully supported by MS Visual Studio. If you need to compile your code with MSVC++ or you need to support both GCC &amp; MSVC++ please refer to the [MSC++ Quickstart](Quickstart-MSC).</p>
<p>Assuming we have the following interface: </p><div class="fragment"><div class="line"> {C++}</div><div class="line">struct SomeInterface {</div><div class="line">   virtual int foo(int) = 0;</div><div class="line">   virtual int bar(int,int) = 0;</div><div class="line">};</div></div><!-- fragment --><p> ## Stubbing </p><div class="fragment"><div class="line"> {C++}</div><div class="line">Mock&lt;SomeInterface&gt; mock;</div><div class="line">// Stub a method to return a value once</div><div class="line">When(mock[&amp;SomeInterface::foo]).Return(1);</div><div class="line"></div><div class="line">// Stub multiple return values (The next two lines do exactly the same)</div><div class="line">When(mock[&amp;SomeInterface::foo]).Return(1,2,3);</div><div class="line">When(mock[&amp;SomeInterface::foo]).Return(1).Return(2).Return(3);</div><div class="line"></div><div class="line">// Return the same value many times (56 in this example)</div><div class="line">When(mock[&amp;SomeInterface::foo]).Return(56_Times(1));</div><div class="line"></div><div class="line">// Return many values many times (First 100 calls will return 1, next 200 calls will return 2)</div><div class="line">When(mock[&amp;SomeInterface::foo]).Return(100_Times(1), 200_Times(2));</div><div class="line"></div><div class="line">// Always return a value (The next two lines do exactly the same)</div><div class="line">When(mock[&amp;SomeInterface::foo]).AlwaysReturn(1);</div><div class="line">mock[&amp;SomeInterface::foo] = 1;</div></div><!-- fragment --><p> <b>What if I want to be more specific?</b> </p><div class="fragment"><div class="line"> {C++}</div><div class="line">// Stub foo(1) to return the value &#39;100&#39; once (The next two lines do the same)</div><div class="line">When(mock[&amp;SomeInterface::foo].Using(1)).Return(100);</div><div class="line">When(mock[&amp;SomeInterface::foo](1)).Return(100);</div><div class="line"></div><div class="line">// Stub &#39;foo(1)&#39; to always return &#39;100&#39;. For all other calls always return 0.</div><div class="line">When(mock[&amp;SomeInterface::foo]).AlwaysReturn(0); // Any invocation of foo will return 0</div><div class="line">When(mock[&amp;SomeInterface::foo].Using(1)).AlwaysReturn(100); // override only for &#39;foo(1)&#39;</div><div class="line"></div><div class="line">// The next two lines do exactly the same</div><div class="line">When(mock[&amp;SomeInterface::foo].Using(1)).AlwaysReturn(0);</div><div class="line">mock[&amp;SomeInterface::foo].Using(1) = 0;</div></div><!-- fragment --><p> <b>Can I stub a method to throw an exception?</b> </p><div class="fragment"><div class="line"> {C++}</div><div class="line">// Throw once</div><div class="line">When(mock[&amp;SomeInterface::foo]).Throw(exception());</div><div class="line">// Throw several times</div><div class="line">When(mock[&amp;SomeInterface::foo]).Throw(exception(),exception());</div><div class="line">// Throw many times</div><div class="line">When(mock[&amp;SomeInterface::foo]).Throw(23_Times(exception()));</div><div class="line">// Always throw</div><div class="line">When(mock[&amp;SomeInterface::foo]).AlwaysThrow(exception());</div></div><!-- fragment --><p> <b>Nice, but sometimes I need something more freestyle</b> </p><div class="fragment"><div class="line"> {C++}</div><div class="line">// Do whatever you want using lambda expressions</div><div class="line">When(mock[&amp;SomeInterface::foo]).Do([](int a)-&gt;int{ ... });</div><div class="line">When(mock[&amp;SomeInterface::foo]).AlwaysDo([](int a)-&gt;int{ ... });</div></div><!-- fragment --><p> ## Invocation Matching </p><div class="fragment"><div class="line"> {C++}</div><div class="line">// Stub foo to return 1 only when argument &#39;a&#39; is even.</div><div class="line">auto agrument_a_is_even = [](int a){return a%2==0;};</div><div class="line">When(mock[&amp;SomeInterface::foo].Matching(agrument_a_is_even)).Return(1);</div><div class="line"></div><div class="line">// Throw exception only when argument &#39;a&#39; is negative.</div><div class="line">auto agrument_a_is_negative = [](int a){return a &lt; 0;};</div><div class="line">When(mock[&amp;SomeInterface::foo].Matching(agrument_a_is_negative)).Throw(exception());</div><div class="line"></div><div class="line">// Stub bar to throw exception only when argument &#39;a&#39; is bigger than argument &#39;b&#39;.</div><div class="line">auto a_is_bigger_than_b = [](int a, int b){return a &gt; b;};</div><div class="line">When(mock[&amp;SomeInterface::bar].Matching(a_is_bigger_than_b)).Throw(exception());</div></div><!-- fragment --><p>## Verification </p><div class="fragment"><div class="line"> {C++}</div><div class="line">Mock&lt;SomeInterface&gt; mock;</div><div class="line">When(mock[&amp;SomeInterface::foo]).AlwaysReturn(1);</div><div class="line"></div><div class="line">SomeInterface &amp; i = mock.get();</div><div class="line"></div><div class="line">// Production code:</div><div class="line">i.foo(1);</div><div class="line">i.foo(2);</div><div class="line">i.foo(3);</div><div class="line"></div><div class="line">// Verify foo was invoked at least once. (The four lines do exactly the same)</div><div class="line">Verify(mock[&amp;SomeInterface::foo]);</div><div class="line">Verify(mock[&amp;SomeInterface::foo]).AtLeastOnce();</div><div class="line">Verify(mock[&amp;SomeInterface::foo]).AtLeast(1);</div><div class="line">Verify(mock[&amp;SomeInterface::foo]).AtLeast(1_Time);</div><div class="line"></div><div class="line">// Verify foo was invoked at exactly 3 times. (The next two lines do exactly the same)</div><div class="line">Verify(mock[&amp;SomeInterface::foo]).Exactly(3);</div><div class="line">Verify(mock[&amp;SomeInterface::foo]).Exactly(3_Times);</div><div class="line"></div><div class="line">// Verify foo(1) was invoked exactly once</div><div class="line">Verify(mock[&amp;SomeInterface::foo].Using(1)).Once();</div><div class="line">Verify(mock[&amp;SomeInterface::foo].Using(1)).Exactly(Once);</div></div><!-- fragment --><p> <b>Wow, can I verify the order of invocations too?</b> </p><div class="fragment"><div class="line"> {C++}</div><div class="line">// Verify foo(1) was invoked before foo(3)</div><div class="line">Verify(mock[&amp;SomeInterface::foo].Using(1), mock[&amp;SomeInterface::foo].Using(3));</div></div><!-- fragment --><p> <b>What about an exact sequence? Can I verify an exact sequence of invocations?</b></p>
<p>Sure, you represent a sequence in the following way:</p>
<p>Two consecutive invocations of foo: </p><div class="fragment"><div class="line"> {C++}</div><div class="line">mock[&amp;SomeInterface::foo] * 2</div></div><!-- fragment --><p> An invocation of foo followed by an invocation of bar: </p><div class="fragment"><div class="line"> {C++}</div><div class="line">mock[&amp;SomeInterface::foo] + mock[&amp;SomeInterface::bar]</div></div><!-- fragment --><p> Two consecutive invocations of foo + bar, i.e. foo + bar + foo + bar </p><div class="fragment"><div class="line"> {C++}</div><div class="line">(mock[&amp;SomeInterface::foo] + mock[&amp;SomeInterface::bar]) * 2</div></div><!-- fragment --><p> This way you can represent any sequence of invocations.</p>
<p>To verify that a specific sequence exists in the actual invocation sequence simply write: </p><div class="fragment"><div class="line"> {C++}</div><div class="line">// verify the actual invocation sequence contains two consecutive invocations of foo at least once.</div><div class="line">Verify(mock[&amp;SomeInterface::foo] * 2); </div><div class="line"></div><div class="line">// verify the actual invocation sequence contains two consecutive invocations of foo exactly once.</div><div class="line">Verify(mock[&amp;SomeInterface::foo] * 2).Exactly(Once);</div><div class="line"></div><div class="line">// verify the actual invocation sequence contains an invocation of foo(1) followed by bar(1,2) exactly twice.</div><div class="line">Verify(mock[&amp;SomeInterface::foo].Using(1) + mock[&amp;SomeInterface::bar].Using(1,2)).Exactly(2_Times);</div></div><!-- fragment --><p> <b>Can a sequence involve more than one mock instance?</b></p>
<p>Sure, a sequence can involve multiple mock instances. </p><div class="fragment"><div class="line"> {C++}</div><div class="line">Mock&lt;SomeInterface&gt; mock1;</div><div class="line">Mock&lt;SomeInterface&gt; mock2;</div><div class="line"></div><div class="line">When(mock1[&amp;SomeInterface::foo]).AlwaysReturn(0);</div><div class="line">When(mock2[&amp;SomeInterface::foo]).AlwaysReturn(0);</div><div class="line"></div><div class="line">SomeInterface &amp; i1 = mock1.get();</div><div class="line">SomeInterface &amp; i2 = mock2.get();</div><div class="line"></div><div class="line">// Production code:</div><div class="line">i1.foo(1);</div><div class="line">i2.foo(1);</div><div class="line">i1.foo(2);</div><div class="line">i2.foo(2);</div><div class="line">i1.foo(3);</div><div class="line">i2.foo(3);</div><div class="line"></div><div class="line">// Verify exactly 3 occurrences of the sequence {mock1.foo(any int) + mock2.foo(any int)}.</div><div class="line">Verify(mock1[&amp;SomeInterface::foo] + mock2[&amp;SomeInterface::foo]).Exactly(3_Times);</div></div><!-- fragment --><p>### Verify No Other Invocations </p><div class="fragment"><div class="line"> {C++}</div><div class="line">Mock&lt;SomeInterface&gt; mock;</div><div class="line">When(mock[&amp;SomeInterface::foo]).AlwaysReturn(0);</div><div class="line">When(mock[&amp;SomeInterface::bar]).AlwaysReturn(0);</div><div class="line">SomeInterface&amp; i  = mock.get();</div><div class="line"></div><div class="line">// call foo twice and bar once.</div><div class="line">i.foo(1);</div><div class="line">i.foo(2);</div><div class="line">i.bar(&quot;some string&quot;);</div><div class="line"></div><div class="line">// verify foo(1) was called.</div><div class="line">Verify(mock[&amp;SomeInterface::foo].Using(1));</div><div class="line"></div><div class="line">// Verify no other invocations of any method of mock. </div><div class="line">// Will fail since foo(2) &amp; bar(&quot;some string&quot;) are not verified yet.</div><div class="line">VerifyNoOtherInvocations(mock);</div><div class="line"></div><div class="line">// Verify no other invocations of method foo only.</div><div class="line">// Will fail since foo(2) is not verified yet.</div><div class="line">VerifyNoOtherInvocations(mock[&amp;SomeInterface::foo]);</div><div class="line"> </div><div class="line">Verify(mock[&amp;SomeInterface::foo].Using(2));</div><div class="line"></div><div class="line">// Verify no other invocations of any method of mock. </div><div class="line">// Will fail since bar(&quot;some string&quot;) is not verified yet.</div><div class="line">VerifyNoOtherInvocations(mock);</div><div class="line"></div><div class="line">// Verify no other invocations of method foo only.</div><div class="line">// Will pass since both foo(1) &amp; foo(2) are now verified.</div><div class="line">VerifyNoOtherInvocations(mock[&amp;SomeInterface::foo]);</div><div class="line"></div><div class="line">Verify(mock[&amp;SomeInterface::bar]); // verify bar was invoked (with any arguments)</div><div class="line"></div><div class="line">// Verify no other invocations of any method of mock. </div><div class="line">// Will pass since foo(1) &amp; foo(2) &amp; bar(&quot;some string&quot;) are now verified.</div><div class="line">VerifyNoOtherInvocations(mock);.</div></div><!-- fragment --> <h3>Verification Scoping</h3>
<p>Verification Scoping is the method of explicitly specifying the set of actual invocations used to verify a sequence.</p>
<p>Assuming we have the following interfaces: </p><div class="fragment"><div class="line"> {C++}</div><div class="line">struct IA {</div><div class="line">   virtual void a1(int) = 0;</div><div class="line">   virtual void a2(int) = 0;</div><div class="line">};</div><div class="line">struct IB {</div><div class="line">   virtual void b1(int) = 0;</div><div class="line">   virtual void b2(int) = 0;</div><div class="line">};</div></div><!-- fragment --><p> And the following 2 mock objects </p><div class="fragment"><div class="line"> {C++}</div><div class="line">Mock&lt;IA&gt; aMock;</div><div class="line">Mock&lt;IB&gt; bMock;</div></div><!-- fragment --><p> And the production code creates the following actual invocation list </p><div class="fragment"><div class="line"> {C++}</div><div class="line">aMock.a1(1);</div><div class="line">bMock.b1(1);</div><div class="line">aMock.a2(1);</div><div class="line">bMock.b2(1);</div></div><!-- fragment --><p> Then </p><div class="fragment"><div class="line"> {C++}</div><div class="line">// Will PASS since the scenario {aMock.a1 + bMock.b1} is part of the   </div><div class="line">// actual list {aMock.a1 + bMock.b1 + aMock.a2 + bMock.b2} </div><div class="line">Using(aMock,bMock).Verify(aMock[&amp;IA::a1] + bMock[&amp;IB::b1]); </div><div class="line"></div><div class="line">// Will FAIL since the scenario {aMock.a1 + bMock.b1} is not part of the   </div><div class="line">// actual list {aMock.a1 + aMock.a2} </div><div class="line">Using(aMock).Verify(aMock[&amp;IA::a1] + bMock[&amp;IB::b1]); </div><div class="line"></div><div class="line">// Will PASS since the scenario {aMock.a1 + aMock.a2} is part of the   </div><div class="line">// actual list {aMock.a1 + aMock.a2}</div><div class="line">Using(aMock).Verify(aMock[&amp;IA::a1] + aMock[&amp;IA::a2]); </div></div><!-- fragment --><p>By default, FakeIt uses all the mock objects that are involved in the verified scenario to implicitly define the verification scope. I.e. the two following lines do exactly the same: </p><div class="fragment"><div class="line"> {C++}</div><div class="line">// Use all methods invocations of aMock &amp; bMock explicitly</div><div class="line">Using(aMock,bMock).Verify(aMock[&amp;IA::a1] + bMock[&amp;IB::b1]); </div><div class="line"></div><div class="line">// Use all methods invocations of aMock &amp; bMock implicitly</div><div class="line">Verify(aMock[&amp;IA::a1] + bMock[&amp;IB::b1]); </div></div><!-- fragment --> <h2>Spying</h2>
<p>In some cases it is very useful to spy an existing object. FakeIt is the ONLY C++ open source mocking framework that supports spying. </p><div class="fragment"><div class="line"> {C++}</div><div class="line">class SomeClass {</div><div class="line">public:</div><div class="line">   virtual int func1(int arg) {</div><div class="line">      return arg;</div><div class="line">   }</div><div class="line">   virtual int func2(int arg) {</div><div class="line">      return arg;</div><div class="line">   }</div><div class="line">};</div><div class="line"></div><div class="line">SomeClass obj;</div><div class="line">Mock&lt;SomeClass&gt; spy(obj);</div><div class="line"></div><div class="line">When(spy[&amp;SomeClass::func1]).AlwaysReturn(10); // Override to return 10</div><div class="line"></div><div class="line">SomeClass&amp; i = spy.get();</div><div class="line">cout &lt;&lt; i.func1(1); // will print 10. </div><div class="line">cout &lt;&lt; i.func2(1); // func2 is not stubbed.</div></div><!-- fragment --><p> In general, all stubbing &amp; verifying features work on spy objects the same way they work on mock objects. </p><h2>Reset <a class="el" href="classMock.html">Mock</a> to Initial State</h2>
<p>In most cases you will need to reset the mock objects to the initial state before/after each test method. To do that simply add the following line for each mock object to the setup/teardown code of your tests. </p><div class="fragment"><div class="line"> {C++}</div><div class="line">mock.Reset();</div></div><!-- fragment --><p> ## Inheritance &amp; Dynamic Casting </p><div class="fragment"><div class="line"> {C++}</div><div class="line">struct A {</div><div class="line">  virtual int foo() = 0;</div><div class="line">};</div><div class="line"></div><div class="line">struct B : public A {</div><div class="line">  virtual int foo() override = 0;</div><div class="line">};</div><div class="line"></div><div class="line">struct C : public B</div><div class="line">{</div><div class="line">   virtual int foo() override = 0;</div><div class="line">};</div></div><!-- fragment --><p> <b>upcast support</b> </p><div class="fragment"><div class="line"> {C++}</div><div class="line">Mock&lt;C&gt; cMock;      </div><div class="line">When(cMock[&amp;C::foo]).AlwaysReturn(0);</div><div class="line"></div><div class="line">C&amp; c = cMock.get();</div><div class="line">B&amp; b = c;</div><div class="line">A&amp; a = b;</div><div class="line"></div><div class="line">cout &lt;&lt; c.foo(); // prints 0</div><div class="line">cout &lt;&lt; b.foo(); // prints 0</div><div class="line">cout &lt;&lt; a.foo(); // prints 0</div></div><!-- fragment --><p> <b>dynamic_cast support</b> </p><div class="fragment"><div class="line"> {C++}</div><div class="line">Mock&lt;C&gt; cMock;</div><div class="line">When(cMock[&amp;C::foo]).AlwaysReturn(0);</div><div class="line"></div><div class="line">A&amp; a = cMock.get(); // get instance and upcast to A&amp;</div><div class="line"></div><div class="line">B&amp; b = dynamic_cast&lt;B&amp;&gt;(a); // downcast to B&amp;</div><div class="line">cout &lt;&lt; b.foo(); // prints 0</div><div class="line"></div><div class="line">C&amp; c = dynamic_cast&lt;C&amp;&gt;(a); // downcast to C&amp;</div><div class="line">cout &lt;&lt; c.foo(); // prints 0</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
